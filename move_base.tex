\documentclass[oribibl]{llncs}

\usepackage[T1]{fontenc} \usepackage[utf8]{inputenc} \usepackage[german]{babel}

\usepackage{cite} %Vereinfachung der Referenzen: [1], [2], [3] => [1-3]
\usepackage{makeidx}         % allows index generation

\usepackage{graphicx} \usepackage[cmex10]{amsmath} %mathamatische Formeln %\usepackage{stfloat} %Bilder über zwei Spalten &\usepackage{url}
\makeindex             % used for the subject index

\begin{document} \title{ROS - Move Base}

\author{Nicolas Limpert \and Christian Schnieder} \institute{Fachhochschule Aachen - University of Applied Sciences \and Robotik WS 2014 / 2015 }

\maketitle
%\tableofcontents


\begin{abstract} Dieser Bericht stellt eine Zusammenfassung der verschiedenen Komponenten des in ROS implementierten Move\_Base-Pakets dar, das ROS-Package move\_base stellt  die Möglichkeit dar mit gegebener Karte und Anfangsposition ein örtliches Ziel mit einem Roboter zu erreichen, dessen TODO \end{abstract}
\newpage


\section{Einleitung}
Das Move\_Base-Paket ist ein ROS-Paket, das dazu verwendet wird einem Roboter ein örtliches Ziel zu vermitteln und dieses Ziel in Kombination von mehreren ROS-Nodes (globalen- und lokalen Planer, globale und lokale costmap, etc.) zu versuchen, zu erreichen.\\
Das Ziel wird der Move Base in Form einer Action vermittelt, mit der Idee aus einer ROS-Message nach Möglichkeit eine Reihe von Fahrbefehlen unter Berücksichtigung von Kollisionsvermeidung, optimaler Pfadplanung (in Abhängigkeit von lokalem und globalem Planner) auszuführen.\\
Das Move\_Base-Paket stellt dadurch einen essentiellen Teil des nav\_cores in ROS dar, da es einem Benutzer bzw. einer Anwendung einfach ermöglicht ein gewünschtes örtliches Ziel zu erreichen, indem das Zusammenspiel zwischen den verschiedenen Komponenten des nav\_cores koordiniert wird.

\section{Motivation}
Aufgrund der steigenden Komplexität in Robotersystemen möchte man die verschiedenen Teilaufgaben gemäß moderner Softwareentwicklungsverfahren gestalten bzw. wie in der objektorientierten Softwareentwicklung einer Instanz des Systems eine Aufgabe erteilen, die sich dann um die Erfüllung (oder Scheiterung) dieser Aufgabe kümmert.\\
Durch eine geschickte Gestaltung der verschiedenen Softwarekomponenten erhält man eine einfache Wart- und Erweiterbarkeit des Systems, die sich in einem Robotersystem so äußern könnte dass man einem Teil der Software mitteilt dass man ein bestimmtes Ziel erreichen möchte und dieses Ziel dann von diesem Teil erfüllt wird.\\
Dies ermöglicht die Move\_Base, in dem ihr mittels ROS-Message ein Ziel in Form einer geometry\_msgs/PoseStamped Nachricht vermittelt wird, welches Ziel zu erreichen ist. Nachfolgend wird im Detail erklärt, welche Komponenten dabei wichtige Rollen spielen.
\newpage
\section{Komponenten}
Move\_base besteht aus folgenden Komponenten: \cite{moveBase}
\begin{figure}
	\centering
  \includegraphics[width=\textwidth]{overview_tf.png}
	\caption{Komponentenübersicht}
	\cite{moveBaseComponenents}
	\label{fig2}
\begin{description}	
\item[Globaler Planer]
Dies kann ein beliebiger globaler Planer sein, solange er das Interface nav\_core::BaseGlobalPlanner erfüllt. Er ist für die Pfadplanung innerhalb der Karte zuständig, führt also beispielsweise eine A* - Suche durch, um von einem gegebenen Anfangspunkt den gewünschten Endpunkt zu erreichen.
\item[Lokaler Planer]
Dies kann ein beliebiger Planer sein, solange er das Interface nav\_core::BaseLocalPlanner erfüllt. Aufgabe des lokalen Planers ist das Erreichen des nächsten Punkts den der globale Planer gegeben hat, bzw. das ausgeben von Fahrbefehlen zum erreichen dieses nächsten Punkts.
\item[Globale Costmap]
Dies kann ein beliebiger Planer sein, solange er das Interface nav\_core::BaseLocalPlanner erfüllt
\item[Lokale Costmap]
Dies kann ein beliebiger Planer sein, solange er das Interface nav\_core::BaseLocalPlanner erfüllt
%\end{description}
\item[Recovery Behaviour]
Dies kann ein beliebiger Planer sein, solange er das Interface nav\_core::BaseLocalPlanner erfüllt.

\end{description}

Nachfolgend werden die einzelnen Komponenten beschrieben.
\end{figure}

\subsection{Globaler Planer}
%A-Stern, navfn, carrot-planner, SBPL
Der globale Planer erhält unter dem ROS-Topic \textit{move\_base\_simple/goal} eine Message vom Typ \textit{geometry\_msgs/PoseStamped}, die unter Berücksichtigung der globalen Costmap beispielsweise mithilfe von A* berechnet, welcher Pfad durch die einzelnen Knotenpunkte in der Karte zum Ziel führen.\\
Hierbei wird seitens der ROS-Wiki als grundliegende Implementationen \textit{navfn} und der \textit{carrot\_planner} aufgeführt:
\subsubsection{navfn}
Über die jeweilige Karte wird ein Grid gelegt, durch das von der Anfangsposition aus bis zum Endpunkt eine Suche mittels Dijkstra durchgeführt wird, die den optimalen Pfad liefert, sofern er verfügbar ist.\\
Laut Diskussion wurde hier auf Dijkstra gesetzt, da er im Vergleich zu einem A* - Algorithmus eher optimale Pfade liefert. \cite{navfn}
\subsubsection{carrot\_planner}
Wenn der Zielpunkt innerhalb eines Objekts liegt, wird entlang des Vektors vom Roboter zur Zielposition so lange zurück gegangen, bis ein Punkt ausserhalb des Objekts gefunden wurde, den der Roboter erreichen kann. Dadurch wird dem Roboter ermöglicht, das Ziel so nah wie möglich zu erreichen. Es wird hierbei also nicht viel geplant, sondern lediglich einem lokalen Planer ein einfacher Plan zur Verfügung gestellt. \cite{carrotPlanner}

\subsection{Lokaler Planer}
%Navigation vom einen Punkt zum nächsten, Kollisionsvermeidung.
Aufgabe des lokalen Planers ist das Erreichen des nächsten Punkts, der im vom globalen Planer übermittelten Plan steht. Grundliegend ist in ROS der \textit{base\_local\_planner} implementiert: \subsubsection{base\_local\_planner}
Dieses Paket beinhaltet zwei verschiedene Implementierungen zur Ausführung eines vom globalen Planer gegebenen Pfads. Dazu zählt das \textit{Trajectory Rollout} und der \textit{Dynamic Window Approach (DWA)}, die folgendes Verfahren gemeinsam haben:
\begin{enumerate}	
\item Ermittle verschiedene Bewegungsmuster die dem Roboter zur Verfügung stehen (dx, dy, dtheta)
\item Simuliere eine Bewegung für jedes dieser Bewegungsmuster um abzuschätzen, was beim Ausführen dieser Bewegung passieren würde wenn die Bewegung für einen bestimmten (kurzen) Zeitraum ausgeführt wird.
\item Bewerte jedes Bewegungsmuster, das in der Simulation ausgeführt wurde anhand von Werten wie Abstand zu anderen Objekten, Nähe zum Zielpunkt, Nähe an den globalen Pfad und Geschwindigkeit. Verwerfe ungültige Bewegungsmuster, also solche, die mit anderen Objekten kollidieren.
\item Nimm das Bewegungsmuster mit der höchsten Bewertung und gebe dieses als ausführbare Steuerbefehle (standardmäßig \textit{geometry\_msgs::Twist} an Topic \textit{cmd\_vel}) aus.
\item Wiederhole ab 1. Punkt.
\end{enumerate}

Der konkrete Unterschied zwischen dem \textit{Trajectory Rollout} und dem \textit{Dynamic Window Approach (DWA)} besteht in der Erstellung der Bewegungsmuster.\\
\textit{Trajectory Rollout} probiert verschiedene mögliche Geschwindigkeiten über die gesamte gegebene Simulationszeit in Abhängigkeit von den für den Roboter möglichen Beschleunigungen.\\
\textit{DWA} probiert die verschiedenen Geschwindigkeiten für nur einen Simulationsschritt (auch in Abhängigkeit von den Beschleunigungen).\\
\textit{DWA} wird laut ROS-Wiki aufgrund seiner höheren Effizienz (es probiert innerhalb von kleineren möglichen Bewegungsmuster als \textit{Trajectory Rollout}) \cite{baseLocalPlanner}
Zum \textit{DWA} gibt es zusätzlich eine separate Implementierung in ROS:\\ \textbf{http://wiki.ros.org/dwa\_local\_planner}.
\subsection{Globale und lokale Costmap}
Die Costmap berechnet anhand von Sensorinformationen ein 2D oder 3D - Raster mit Belegungen und Grid TODO \cite{costmap2d}
%\subsection{Lokale Costmap}
\subsection{Recovery Behaviours}
\section{Beispielhafte Implementierung an einem Rover}
Nachfolgend wird ein Beispiel mithilfe der vom Maskor-Institut der Fachhochschule Aachen gestellten Rover aufgeführt, mit dem die Verwendung der \textit{move\_base} möglich ist, in dem man für den globalen und lokalen Planer andere Pakete nimmt, die sich eher für Roboter eignen, die ein Fahrgestell nach Ackermann besitzen.\\
\subsection{Problem: Ackermann im Vergleich zu (nicht-) holonomen Robotern}
Ein Roboter, der ein Ackermann-Fahrgestell besitzt unterscheidet sich von anderen mobilen Robotern grundliegend darin dass er sich einerseits nicht auf der Stelle drehen kann und sich auch nicht seitlich bewegen kann.\\
Die oben genannten Implementationen der globalen und lokalen Planer gehen aber davon aus dass der Roboter sich zumindest auf der Stelle drehen kann.\\
Dies erschwert die Möglichkeit, den \textit{ROS Navigation Stack} mit Robotern zu verwenden, die Ackermann-getrieben sind.\cite{ackermannGroup}
\subsubsection{Lösung}
Für die Pfadplanung (bzw. Aktionsplanung) existiert eine von der Carnegie Mellon University (Dr. Maxim Likhachev\cite{likhachev}) entwickelte Bibliothek, die sich (\textit{SBPL - Search Based Planning Library})\cite{sbplMain} nennt und es, neben anderen Features, erlaubt unter Verwendung des \textit{SBPL Lattice Planners} eine Folge von Aktionen TODO
\subsection{Globaler Planer}
%SBPL
\subsection{Lokaler Planer}
%Eigener lokaler Planer (Umbau von TrajectoryPlanner)
\subsection{Globale und lokale Costmap}
\subsection{Globale Costmap}
%?
%\subsection{Lokale Costmap}
%?
\subsection{Recovery Behaviours}
%Anpassung, da auch hier kein Drehen auf der Stelle möglich ist.
\section{Action API}
Die move\_base Knoten stellt eine Implementierung des SimpleActionServer (siehe actionlib Dokumentation) zur Verfüpgung der die Ziele der geometry\_msgs/PoseStamped Nachrichten enthält. Die Kommunikation mit den move\_base Knoten ist direkt über ROS möglich. Es wird aber empfohlen die Ziele über den SimpleActionClient zu schicken, sofern eine Nachverfolgung des Status gewünscht wird.
\subsection{Action Subscribed Topics}
\subsubsection{move\_base/goal} (move\_base\_msgs/MoveBaseActionGoal)\\
	Ein Ziel das move\_base in der Welt verfolgen soll.
\subsubsection{move\_base/cancel} (actionlib\_msgs/GoalID)\\
	Anfrage um ein bestimmtes Ziel nicht mehr zu verfolgen.
\subsection{Action Published Topics}
\subsubsection{move\_base/feedback} (move\_base\_msgs/MoveBaseActionFeedback)\\
	Enthält die aktuelle Position der Basis in der Welt
\subsubsection{move\_base/status} (actionlib\_msgs/GoalStatusArray)\\
	Enthät Statusinformationen der Ziele die an move\_base geschickt werden.
\subsubsection{move\_base/result} (move\_base\_msgs/MoveBaseActionResult)\\
	Rückgabewert ist leer für move\_base action.
\section{Topics}
\subsection{Subscribed Topics}
\subsubsection{move\_base\_simple/goal} (geometry\_msgs/PoseStamped)\\
	Bietet ein non-action interface für move\_base für Benutrzer bei dennen die Nachverfolgung der Aktionen nicht relevant ist.
\subsection{Published Topics}
\subsubsection{cmd\_vel} (geometry\_msgs/Twist)\\
	Forlaufende Bewegungsbefejle die durch eine mobile base ausgeführt werden 	sollen.
	
\section{Services}
\subsubsection{make\_plan} (nav\_msgs/GetPlan)\\
	Ermöglicht einem externen Benutzer einen Plan zu einem Ziel zu bekommen ohne 	das move\_base diesen verfolgt.
\subsubsection{clear\_unknown\_space} (std\_srvs/Empty)\\
	Ermöglicht einen externen Benutzer den Bereich um den Roboter auf leer zu setzen. 	Dieses kann verwendet werden wenn der Roboter in einen neue Umgebung gesetzt 	wird.
\subsubsection{clear\_costmaps} (std\_srvs/Empty)\\
	Erlaubt einen externen Benutzer Objecte aus der costmap zu entfernen. Da dieses 	zu Kollisionen führen kann, sollte diese Funktion mit Vorsicht benutzt werden. Sie 	kann dennoch hilfreich sein, wenn es Fehlern in der costmap gibt.
	
\section{Parameter}
Nachfolgend werden Parameter an die Move\_Base aufgelistet, die entweder beim Starten der Move\_Base beispeilsweise in einem Launch-File oder über den ROS-Parameterserver gesetzt werden.
\subsubsection{base\_global\_planner} (string, default: "navfn/NavfnROS")\\
   Name des Plugins das als Globaler Planer mit move\_base benutzt wird. VGL. Abschnitt "Komponenten / Globaler Planer".

\subsubsection{base\_local\_planner} (string, default: "base\_local\_planner/TrajectoryPlannerROS" For 1.1+ series)\\
   VGL. Abschnitt "Komponenten / Lokaler Planer".
   
   
\subsubsection{recovery\_behaviors} (list, default: [{name: conservative\_reset, type: clear\_costmap\_recovery/ClearCostmapRecovery}, {name: rotate\_recovery, type: rotate\_recovery/RotateRecovery}, {name: aggressive\_reset, type: clear\_costmap\_recovery/ClearCostmapRecovery}])\\
   VGL. Abschnitt "Komponenten / Recovery Behaviours".
   
\subsubsection{controller\_frequency} (double, default: 20.0)\\
	Die Rate in Hz in der die Fahrbefehle an den Basiskonten gesendet werden.
	
\subsubsection{planner\_patience} (double, default: 5.0)\\
	Wert wie lange in Sekunden der Planer versucht einen Plan zu finden bis spaceclearing Operationen eingeleitet werden (siehe Recovery Behaviours).
	
\subsubsection{controller\_patience} (double, default: 15.0)\\
	Wert wie lange in Sekunden der Kontroller auf richtige Komandos wartet bis spaceclearing Operationen eingeleitet werden.
	
\subsubsection{conservative\_reset\_dist} (double, default: 3.0)\\
	Abstand von Hindernissen in Meteren zum Roboter die aus der costmap entfernt 	werden wenn versucht wird Platz in der costmap zu schaffen.
	
\subsubsection{recovery\_behavior\_enabled} (bool, default: true)\\
	Ein und ausschalten der move\_base recovery behaviors.

\subsubsection{clearing\_rotation\_allowed} (bool, default: true)\\
	Erlaubt oder Verbietet Rotationen um die eigene Achse beim Versuch von clear out 	space
	Hinweis: Diese Parameter wird nur beim Standard recovery behaviors benutzt

\subsubsection{shutdown\_costmaps} (bool, default: false)\\
	Eingabe Paramter ist ein Boolean. Gibt an ob die costmap ausgeschaltet wird wenn 	die move\_base auf inaktiv gesetzt ist
\subsubsection{oscillation\_timeout} (double, default: 0.0)\\
	Wert in Sekunden bis das recovery behaviour ausgelöst wird.
\subsubsection{oscillation\_distance} (double, default: 0.5)\\
	Strecke in Metern die der Roboter zurücklegen muss um sicher zu sein nicht zu 	schwingen. Setzt den Timer oscillation\_timeout zurück.
\subsubsection{planner\_frequency} (double, default: 0.0)\\
	Frequenz in Hertz in der die Globale Planber Schleife ausgeführt wird.
	0.0 führt den Globalen Planer nur bei einem neuen Ziel aus oder der lokale Planer 	eine unmögliche Route meldet.	
%\subsubsection{•}

%\section{Verwandte Arbeiten/Stand der Technik}

%\section{} \section{Eigene Arbeit} 
%\section{Evaluation} 
%\section{Zusammenfassung/Ausblick}

\bibliographystyle{IEEEtran} \bibliography{paper} %paper ist Literaturverzeichnis


\end{document}
